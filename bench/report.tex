\documentclass[a4paper]{article}
\title{
    Лабораторна робота №3\\
    Визначення швидкодії обчислювальної системи
}
\author{Віннічук Назар K-25}

\usepackage{graphicx}

\usepackage{polyglossia}
\setdefaultlanguage{ukrainian}
\setotherlanguage{english}

\usepackage{fontspec}
\setmainfont{IBM Plex Sans}
\setmonofont{IBM Plex Mono}

\usepackage{minted}

\usepackage[margin=2cm]{geometry}

\usepackage[parfill]{parskip}

\frenchspacing

\newcommand{\code}[1]{\textbf{\texttt{#1}}}

\begin{document}

\maketitle
\tableofcontents

\section{Умова}

\subsection{Постановка задачі}

Лабораторна робота передбачає розробку спрощеної системи тестів, без побудови
генеральної виборки, опитування експертів, проведення статистичних вимірювань.
Необхідно розробити програму, яка вимірює кількість виконуваних базових
операцій (команд) за секунду конкретною ОбСист (комп’ютер + ОС + Система
програмування). Вимірювання "чистої" команди процесора не потрібне (як і є у
реальних програмних комплексах, що типово розробляються на мовах високого
рівня, часто навіть на платформенно незалежних) і фактично не має сенсу. Вибір
системи програмування за критерієм "яка з них генерує швидший код" зайва, -
виберіть ту з них, яка для вас найбільш зручна.

\subsection{Базовий набір операцій}

До базового набору операцій достатньо включити операції додавання, віднімання,
множення та ділення для кожного з базових типів даних (символьний, варіанти
цілого, дійсний тощо, як це є в тій чи тій мові чи системі програмування). Інші
операції, команди та типи – за бажанням. Наприклад, для С/С++ потрібно взяти
типи char, int, long, float та double. Враховуючи, що для всіх типів процесорів
характерне апаратне об’єднання команди додавання та віднімання у одну команду
за рахунок відповідної зміни знаку одного з операндів (але для зручності
кодування на рівні командного набору ці операції фігурують як окремі команди),
не можна проводити вимірювання лише для однієї з цих двох команд. Якраз на цих
двох операціях легко побачити стабільність тесту. Ви побачите, що за
формальною, здавалось би, подібністю додавання та віднімання, добитися
однакового результату непроста задача і потребує деяких "тонких" моментів при
програмуванні.

\section{Реалізація}

\subsection{Вимірювання швидкодії}

Вимірювалась швидкодія інструкцій процесора архітектури \emph{x86\_64}
(також відома як \emph{AMD64}).
Модель процесора — \emph{Intel Core 2 6420 (2) @ 2.128GHz}.
Набір вимірюваних інструкцій:

\begin{itemize}
  \item Цілочисельні операцій
    \begin{itemize}
      \item \code{add}
      \item \code{sub}
      \item \code{div}
      \item \code{mul}
      \item \code{idiv}
      \item \code{imul}
    \end{itemize}
  \item Операції з рухомою крапкою
    \begin{itemize}
      \item \code{fadd}
      \item \code{fsub}
      \item \code{fmul}
      \item \code{fdiv}
      \item \code{fcos}
    \end{itemize}
  \item Побітова арифметика
    \begin{itemize}
      \item \code{shl}
    \end{itemize}
  \item Атомарна арифметика (використовується для синхронізації багатопотокових процесів)
    \begin{itemize}
      \item \code{xadd}
    \end{itemize}
\end{itemize}

Швидкодія цілочисельних інструкцій \code{add}, \code{mul} та \code{div} залежить
від розміру регістрів-операндів, тому у звіті до даних інструкцій додається суфікс:

\begin{itemize}
  \item \code{+}: 8-байтові регістри, наприклад \code{rax}
  \item \emph{без суфіксу}: 4-байтові регістри, наприклад \code{eax}
  \item \code{-}: 2-байтові регістри, наприклад \code{ax}
  \item \code{--}: 1-байтові регістри, наприклад \code{al}
\end{itemize}

Для кожної інструкції було написано дві програми мовою \emph{Flat Assembler}.
Одна програма містила виклик відповідної інструкції у циклі, а друга була копією
першої без виклику інструкції. Таким чином різниця у часі виконання програм відповідає
часу виконання піддослідної інструкції.

Оскільки програми містили однаковий код ініціалізації та завершення вимірювання,
було створено спільний файл-заголовок такого вмісту:

\inputminted{text}{ops/macro/bench.asm}

Приклад програми з викликом інструкції (у цьому разі \code{imul}):

\inputminted{text}{ops/imul/bench.asm}

Відповідна програма без виклику інструкції:

\inputminted{text}{ops/imul/baseline.asm}

\subsection{Візуалізація}

Візуалізація здійснюється скриптами для командної оболонки \emph{bash}.
Скрипт \emph{bench.sh} збирає виконувані програми та вираховує кількість здійснених
операцій за секунду для кожної інструкції:

\inputminted{bash}{bench.sh}

Скрипт \emph{plot.sh} перетворює табличні дані, отримані \emph{bench.sh}, на гістограми.

\inputminted{bash}{plot.sh}

\section{Результати}

Таблиця \emph{bash.sh}:

\begin{minted}[obeytabs]{text}
add	5263157894
add+	5000000000
add-	4761904761
add--	5555555555
div	100000000
div+	62344139
div-	200803212
fadd	11111111
fcos	10869565
fdiv	10869565
fmul	10752688
fsub	11111111
idiv	116144018
imul	641025641
mul	645161290
mul+	364963503
mul-	649350649
mul--	1086956521
shl	5000000000
sub	5000000000
xadd	884955752
\end{minted}

Графік \emph{plot.sh}, лінійна шкала:

\begin{center}
  \includegraphics[scale=0.25]{linear.png}
\end{center}

Графік \emph{plot.sh}, логарифмічна шкала:

\begin{center}
  \includegraphics[scale=0.25]{log.png}
\end{center}

\section{Висновки}

\begin{itemize}
  \item Додавання та віднімання цілих чисел — найшвидша операція, разом з побітовим зсувом.
  \item Вплив розміру регістра на додавання цілих чисел незначний.
  \item Швидкість виконання операцій над числами зі знаком не відрізняється від швидкості
    виконання відповідних операцій над беззнаковими числами.
  \item Швидкість множення та ділення цілих чисел обернено пропорційна розміру регістра.
  \item Ділення цілих чисел на порядок повільніше за множення, яке на порядок повільніше
    за додавання.
  \item Атомарна операція обмін-додавання майже на порядок повільніша за звичайне додавання.
  \item Швидкодія операцій над числами з рухомою комою не залежить від типу операції.
  \item Операції над числами з рухомою комою на порядок повільніші за цілочисельне ділення.
\end{itemize}

\end{document}
